.release_template:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  before_script:
    - apk update && apk add --no-cache git bash jq
    - git --version
    - bash --version
    - jq --version
    - git config user.name "kamran.aliyev"
    - git config user.email "kamran.aliyev@ady.az"
    - git remote set-url origin "https://oauth2:${Kamran_Access_Token}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    - git checkout "$CI_COMMIT_BRANCH"
    - git pull origin "$CI_COMMIT_BRANCH"
  script:
    - |
      #!/bin/bash
      set -e

      # --- 1. DETERMINE VERSION ---
      echo "Determining new version for branch $CI_COMMIT_BRANCH..."

      case "$CI_COMMIT_BRANCH" in
        "dev")
          BRANCH_SUFFIX="-dev"
          VERSION_MANIFEST=".version-manifest.dev.json"
          ;;
        "staging")
          BRANCH_SUFFIX="-pre"
          VERSION_MANIFEST=".version-manifest.pre.json"
          ;;
        "master")
          BRANCH_SUFFIX=""
          VERSION_MANIFEST=".version-manifest.prod.json"
          ;;
        *)
          BRANCH_SUFFIX="-$CI_COMMIT_BRANCH"
          VERSION_MANIFEST=".version-manifest.json"
          ;;
      esac
      
      echo "Using manifest file: $VERSION_MANIFEST"

      # <<< MODIFICATION START: Create manifest if it doesn't exist >>>
      if [ ! -f "$VERSION_MANIFEST" ]; then
        echo "Warning: Manifest file '$VERSION_MANIFEST' not found. Creating a new one."
        # Create a default manifest file.
        printf '{\n  "version": "1.0.0",\n  "auto-increment": true,\n  "increment-type": "patch"\n}\n' > "$VERSION_MANIFEST"
        # Stage the new file so it gets committed later.
        git add "$VERSION_MANIFEST"
        echo "Created and staged '$VERSION_MANIFEST'."
      fi
      # <<< MODIFICATION END >>>

      # Now, read the values from the (now guaranteed to exist) manifest file.
      MANIFEST_VERSION=$(jq -r '.version // "1.0.0"' "$VERSION_MANIFEST")
      AUTO_INCREMENT=$(jq -r '.["auto-increment"]' "$VERSION_MANIFEST")
      if [ "$AUTO_INCREMENT" != "false" ]; then
        AUTO_INCREMENT="true"
      else
        AUTO_INCREMENT="false"
      fi
      echo "AUTO_INCREMENT is: '$AUTO_INCREMENT'"
      INCREMENT_TYPE=$(jq -r '.["increment-type"] // "patch"' "$VERSION_MANIFEST")

      LAST_TAG=$(git tag --list "v*[0-9]*${BRANCH_SUFFIX}" | sort -V | tail -n 1)

      if [ -z "$LAST_TAG" ]; then
        # Use a base tag that ensures the grep below fails, forcing use of MANIFEST_VERSION
        LAST_TAG="v0.0.0${BRANCH_SUFFIX}"
        echo "No previous tag found for this branch suffix. Will start from version in manifest."
      fi

      echo "Last tag for $CI_COMMIT_BRANCH: $LAST_TAG"

      if [ "$AUTO_INCREMENT" = "true" ]; then
        # Check if the last tag is a valid semver tag
        if echo "$LAST_TAG" | grep -q '^v[0-9]\+\.[0-9]\+\.[0-9]\+'; then
          MAJOR=$(echo "$LAST_TAG" | sed 's/^v\([0-9]\+\)\..*/\1/')
          MINOR=$(echo "$LAST_TAG" | sed 's/^v[0-9]\+\.\([0-9]\+\)\..*/\1/')
          PATCH=$(echo "$LAST_TAG" | sed 's/^v[0-9]\+\.[0-9]\+\.\([0-9]\+\).*/\1/')
          case "$INCREMENT_TYPE" in
            "major") NEW_TAG="v$((MAJOR + 1)).0.0${BRANCH_SUFFIX}";;
            "minor") NEW_TAG="v${MAJOR}.$((MINOR + 1)).0${BRANCH_SUFFIX}";;
            "patch"|*) NEW_TAG="v${MAJOR}.${MINOR}.$((PATCH + 1))${BRANCH_SUFFIX}";;
          esac
        else
          # Fallback if no valid last tag was found (e.g., initial run)
          NEW_TAG="v${MANIFEST_VERSION}${BRANCH_SUFFIX}"
        fi
      else
        NEW_TAG="v${MANIFEST_VERSION}${BRANCH_SUFFIX}"
      fi

      echo "New tag will be: $NEW_TAG"
      if git rev-parse "$NEW_TAG" >/dev/null 2>&1; then
        echo "Tag $NEW_TAG already exists. Skipping release."
        exit 0
      fi

      echo "RELEASE_TAG=$NEW_TAG" > release.env
      echo "RELEASE_BRANCH=$CI_COMMIT_BRANCH" >> release.env
      echo "release.env created for artifact collection."

      # --- 2. GENERATE AND COMMIT RELEASE ARTIFACTS ---
      echo "Generating release artifacts..."
      
      CHANGELOG_CONTENT=$(printf "Automatic release for branch **%s**.\n\n### Changes since %s\n" \
        "$CI_COMMIT_BRANCH" \
        "$LAST_TAG"
      )
      CHANGES=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges 2>/dev/null || echo "- Initial release")
      CHANGELOG_CONTENT="${CHANGELOG_CONTENT}${CHANGES}"

      
      if [ "$AUTO_INCREMENT" = "true" ]; then
        CLEAN_VERSION=$(echo "$NEW_TAG" | sed "s/^v//" | sed "s/${BRANCH_SUFFIX}$//")
        echo "Updating manifest '$VERSION_MANIFEST' with new version: $CLEAN_VERSION"
        jq --arg version "$CLEAN_VERSION" '.version = $version' "$VERSION_MANIFEST" > "${VERSION_MANIFEST}.tmp"
        mv "${VERSION_MANIFEST}.tmp" "$VERSION_MANIFEST"
      fi

      if [ -f "$VERSION_MANIFEST" ]; then
        git add "$VERSION_MANIFEST"
      fi

      if ! git diff-index --quiet --cached HEAD; then
        git commit -m "chore(release):  Update version manifest for $NEW_TAG [skip ci]"
        echo "Committed  version manifest."
      else
        echo "No new changes to commit for the release."
      fi

      # --- 3. PUSH, TAG, AND CREATE RELEASE ---
      git push origin "$CI_COMMIT_BRANCH"
      
      git tag -a "$NEW_TAG" -m "Release $NEW_TAG"
      git push origin "$NEW_TAG"
      echo "Pushed tag $NEW_TAG to remote."
      
      echo "Creating GitLab Release..."
      release-cli create --name "Release $NEW_TAG" --tag-name "$NEW_TAG" \
        --description "Automatic release for branch **$CI_COMMIT_BRANCH**." \
        --assets-link "{\"name\":\"${VERSION_MANIFEST}\",\"url\":\"${CI_PROJECT_URL}/-/blob/$NEW_TAG/${VERSION_MANIFEST}\",\"filepath\":\"/${VERSION_MANIFEST}\"}"

  artifacts:
    reports:
      dotenv: release.env
    paths:
      - release.env
      - .version-manifest.dev.json
      - .version-manifest.pre.json
      - .version-manifest.prod.json
    expire_in: 1 week

# Pre-defined release jobs for common branches
release_dev:
  extends: .release_template
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev" && $CI_COMMIT_MESSAGE !~ /^chore\(release\):/'
      when: always

release_staging:
  extends: .release_template
  rules:
    - if: '$CI_COMMIT_BRANCH == "staging" && $CI_COMMIT_MESSAGE !~ /^chore\(release\):/'
      when: always

release_prod:
  extends: .release_template
  rules:
    - if: '$CI_COMMIT_BRANCH == "master" && $CI_COMMIT_MESSAGE !~ /^chore\(release\):/'
      when: always
